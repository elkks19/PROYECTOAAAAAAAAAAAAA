import * as isIBAN from 'validator/lib/isIBAN.js';
import * as validator from 'validator';
import * as validator_lib_isURL_js from 'validator/lib/isURL.js';
import * as validator_lib_isEmail_js from 'validator/lib/isEmail.js';
import { V as Validator, a as Validation, F as FieldOptions, P as Parser, R as RuleBuilder, b as PARSE, c as ParserOptions, C as ConstructableSchema, O as OTYPE, d as COTYPE, T as Transformer, S as SchemaTypes, U as UnionNoMatchCallback, e as UNIQUE_NAME, I as IS_OF_TYPE, M as MobileOptions, f as CreditCardOptions, g as PassportOptions, h as PostalCodeOptions, A as AlphaOptions, i as AlphaNumericOptions, E as EnumLike, j as ErrorReporterContract, k as MetaDataValidator, l as ValidationOptions, m as Infer, n as ValidationError, o as ValidationMessages, p as ValidationFields } from './types-8973fb04.js';
export { s as symbols } from './types-8973fb04.js';
import Macroable from '@poppinss/macroable';
import * as _vinejs_compiler_types from '@vinejs/compiler/types';
import { RefsStore, LiteralNode, FieldContext, ConditionalFn, UnionNode, CompilerNodes, TupleNode, ArrayNode, ObjectGroupNode, ObjectNode, RecordNode, MessagesProviderContact } from '@vinejs/compiler/types';
import * as normalize_url from 'normalize-url';
import { NormalizeEmailOptions } from 'validator/lib/normalizeEmail.js';
export { S as SimpleErrorReporter } from './simple_error_reporter-8927be32.js';
import 'validator/lib/isMobilePhone.js';
import 'validator/lib/isPostalCode.js';

/**
 * Returns args for the validation function.
 */
type GetArgs<T> = undefined extends T ? [options?: T] : [options: T];
/**
 * Convert a validator function to a rule that you can apply
 * to any schema type using the `schema.use` method.
 */
declare function createRule<Options = undefined>(validator: Validator<Options>, metaData?: {
    implicit?: boolean;
    isAsync?: boolean;
}): (...options: GetArgs<Options>) => Validation<Options>;

/**
 * Base schema type with only modifiers applicable on all the schema types.
 */
declare abstract class BaseModifiersType$1<Output, CamelCaseOutput> extends Macroable implements ConstructableSchema<Output, CamelCaseOutput> {
    /**
     * Each subtype should implement the compile method that returns
     * one of the known compiler nodes
     */
    abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode;
    /**
     * The child class must implement the clone method
     */
    abstract clone(): this;
    /**
     * The output value of the field. The property points to a type only
     * and not the real value.
     */
    [OTYPE]: Output;
    [COTYPE]: CamelCaseOutput;
    /**
     * Mark the field under validation as optional. An optional
     * field allows both null and undefined values.
     */
    optional(): OptionalModifier$1<this>;
    /**
     * Mark the field under validation to be null. The null value will
     * be written to the output as well.
     *
     * If `optional` and `nullable` are used together, then both undefined
     * and null values will be allowed.
     */
    nullable(): NullableModifier$1<this>;
    /**
     * Apply transform on the final validated value. The transform method may
     * convert the value to any new datatype.
     */
    transform<TransformedOutput>(transformer: Transformer<this, TransformedOutput>): TransformModifier<this, TransformedOutput>;
}
/**
 * Modifies the schema type to allow null values
 */
declare class NullableModifier$1<Schema extends BaseModifiersType$1<any, any>> extends BaseModifiersType$1<Schema[typeof OTYPE] | null, Schema[typeof COTYPE] | null> {
    #private;
    constructor(parent: Schema);
    /**
     * Creates a fresh instance of the underlying schema type
     * and wraps it inside the nullable modifier
     */
    clone(): this;
    /**
     * Compiles to compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode;
}
/**
 * Modifies the schema type to allow undefined values
 */
declare class OptionalModifier$1<Schema extends BaseModifiersType$1<any, any>> extends BaseModifiersType$1<Schema[typeof OTYPE] | undefined, Schema[typeof COTYPE] | undefined> {
    #private;
    constructor(parent: Schema);
    /**
     * Creates a fresh instance of the underlying schema type
     * and wraps it inside the optional modifier
     */
    clone(): this;
    /**
     * Compiles to compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode;
}
/**
 * Modifies the schema type to allow custom transformed values
 */
declare class TransformModifier<Schema extends BaseModifiersType$1<any, any>, Output> extends BaseModifiersType$1<Output, Output> {
    #private;
    /**
     * The output value of the field. The property points to a type only
     * and not the real value.
     */
    [OTYPE]: Output;
    [COTYPE]: Output;
    constructor(transform: Transformer<Schema, Output>, parent: Schema);
    /**
     * Creates a fresh instance of the underlying schema type
     * and wraps it inside the transform modifier.
     */
    clone(): this;
    /**
     * Compiles to compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode;
}
/**
 * The base type for creating a custom literal type. Literal type
 * is a schema type that has no children elements.
 */
declare abstract class BaseLiteralType<Output, CamelCaseOutput> extends BaseModifiersType$1<Output, CamelCaseOutput> {
    /**
     * The child class must implement the clone method
     */
    abstract clone(): this;
    /**
     * Field options
     */
    protected options: FieldOptions;
    /**
     * Set of validations to run
     */
    protected validations: Validation<any>[];
    constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]);
    /**
     * Shallow clones the validations. Since, there are no API's to mutate
     * the validation options, we can safely copy them by reference.
     */
    protected cloneValidations(): Validation<any>[];
    /**
     * Shallow clones the options
     */
    protected cloneOptions(): FieldOptions;
    /**
     * Compiles validations
     */
    protected compileValidations(refs: RefsStore): {
        ruleFnId: `ref://${number}`;
        implicit: boolean;
        isAsync: boolean;
    }[];
    /**
     * Define a method to parse the input value. The method
     * is invoked before any validation and hence you must
     * perform type-checking to know the value you are
     * working it.
     */
    parse(callback: Parser): this;
    /**
     * Push a validation to the validations chain.
     */
    use(validation: Validation<any> | RuleBuilder): this;
    /**
     * Enable/disable the bail mode. In bail mode, the field validations
     * are stopped after the first error.
     */
    bail(state: boolean): this;
    /**
     * Compiles the schema type to a compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode;
}

/**
 * VineAny represents a value that can be anything
 */
declare class VineAny extends BaseLiteralType<any, any> {
    constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]);
    /**
     * Clones the VineAny schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * VineEnum represents a enum data type that performs validation
 * against a pre-defined choices list.
 */
declare class VineEnum<const Values extends readonly unknown[]> extends BaseLiteralType<Values[number], Values[number]> {
    #private;
    /**
     * Default collection of enum rules
     */
    static rules: {
        enum: (options: {
            choices: readonly any[] | ((field: FieldContext) => readonly any[]);
        }) => Validation<{
            choices: readonly any[] | ((field: FieldContext) => readonly any[]);
        }>;
    };
    /**
     * Returns the enum choices
     */
    getChoices(): Values | ((field: FieldContext) => Values);
    constructor(values: Values | ((field: FieldContext) => Values), options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Clones the VineEnum schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * Represents a union conditional type. A conditional is a predicate
 * with a schema
 */
declare class UnionConditional<Schema extends SchemaTypes> {
    #private;
    [OTYPE]: Schema[typeof OTYPE];
    [COTYPE]: Schema[typeof COTYPE];
    constructor(conditional: ConditionalFn<Record<string, unknown>>, schema: Schema);
    /**
     * Compiles to a union conditional
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode['conditions'][number];
}

/**
 * Vine union represents a union data type. A union is a collection
 * of conditionals and each condition has an associated schema
 */
declare class VineUnion<Conditional extends UnionConditional<SchemaTypes>> implements ConstructableSchema<Conditional[typeof OTYPE], Conditional[typeof COTYPE]> {
    #private;
    [OTYPE]: Conditional[typeof OTYPE];
    [COTYPE]: Conditional[typeof COTYPE];
    constructor(conditionals: Conditional[]);
    /**
     * Define a fallback method to invoke when all of the union conditions
     * fail. You may use this method to report an error.
     */
    otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this;
    /**
     * Clones the VineUnion schema type.
     */
    clone(): this;
    /**
     * Compiles to a union
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode;
}

/**
 * Create a new union schema type. A union is a collection of conditionals
 * and schema associated with it.
 */
declare function union<Conditional extends UnionConditional<any>>(conditionals: Conditional[]): VineUnion<Conditional>;
declare namespace union {
    var _a: <Schema extends SchemaTypes>(conditon: (value: Record<string, unknown>, field: FieldContext) => any, schema: Schema) => UnionConditional<Schema>;
    var _b: <Schema extends SchemaTypes>(schema: Schema) => UnionConditional<Schema>;
    export { _a as if, _b as else };
}

/**
 * Base schema type with only modifiers applicable on all the schema types.
 */
declare abstract class BaseModifiersType<Output, CamelCaseOutput> extends Macroable implements ConstructableSchema<Output, CamelCaseOutput> {
    /**
     * Each subtype should implement the compile method that returns
     * one of the known compiler nodes
     */
    abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes;
    /**
     * The child class must implement the clone method
     */
    abstract clone(): this;
    /**
     * The output value of the field. The property points to a type only
     * and not the real value.
     */
    [OTYPE]: Output;
    [COTYPE]: CamelCaseOutput;
    /**
     * Mark the field under validation as optional. An optional
     * field allows both null and undefined values.
     */
    optional(): OptionalModifier<this>;
    /**
     * Mark the field under validation to be null. The null value will
     * be written to the output as well.
     *
     * If `optional` and `nullable` are used together, then both undefined
     * and null values will be allowed.
     */
    nullable(): NullableModifier<this>;
}
/**
 * Modifies the schema type to allow null values
 */
declare class NullableModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<Schema[typeof OTYPE] | null, Schema[typeof COTYPE] | null> {
    #private;
    constructor(parent: Schema);
    /**
     * Creates a fresh instance of the underlying schema type
     * and wraps it inside the nullable modifier
     */
    clone(): this;
    /**
     * Compiles to compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes;
}
/**
 * Modifies the schema type to allow undefined values
 */
declare class OptionalModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<Schema[typeof OTYPE] | undefined, Schema[typeof COTYPE] | undefined> {
    #private;
    constructor(parent: Schema);
    /**
     * Creates a fresh instance of the underlying schema type
     * and wraps it inside the optional modifier
     */
    clone(): this;
    /**
     * Compiles to compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes;
}
/**
 * The BaseSchema class abstracts the repetitive parts of creating
 * a custom schema type.
 */
declare abstract class BaseType<Output, CamelCaseOutput> extends BaseModifiersType<Output, CamelCaseOutput> {
    /**
     * Field options
     */
    protected options: FieldOptions;
    /**
     * Set of validations to run
     */
    protected validations: Validation<any>[];
    constructor(options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Shallow clones the validations. Since, there are no API's to mutate
     * the validation options, we can safely copy them by reference.
     */
    protected cloneValidations(): Validation<any>[];
    /**
     * Shallow clones the options
     */
    protected cloneOptions(): FieldOptions;
    /**
     * Compiles validations
     */
    protected compileValidations(refs: RefsStore): {
        ruleFnId: `ref://${number}`;
        implicit: boolean;
        isAsync: boolean;
    }[];
    /**
     * Define a method to parse the input value. The method
     * is invoked before any validation and hence you must
     * perform type-checking to know the value you are
     * working it.
     */
    parse(callback: Parser): this;
    /**
     * Push a validation to the validations chain.
     */
    use(validation: Validation<any> | RuleBuilder): this;
    /**
     * Enable/disable the bail mode. In bail mode, the field validations
     * are stopped after the first error.
     */
    bail(state: boolean): this;
}

/**
 * VineTuple is an array with known length and may have different
 * schema type for each array element.
 */
declare class VineTuple<Schema extends SchemaTypes[], Output extends any[], CamelCaseOutput extends any[]> extends BaseType<Output, CamelCaseOutput> {
    #private;
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of array type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(schemas: [...Schema], options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Copy unknown properties to the final output.
     */
    allowUnknownProperties<Value>(): VineTuple<Schema, [
        ...Output,
        ...Value[]
    ], [
        ...CamelCaseOutput,
        ...Value[]
    ]>;
    /**
     * Clone object
     */
    clone(): this;
    /**
     * Compiles to array data type
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): TupleNode;
}

/**
 * VineArray represents an array schema type in the validation
 * pipeline
 */
declare class VineArray<Schema extends SchemaTypes> extends BaseType<Schema[typeof OTYPE][], Schema[typeof COTYPE][]> {
    #private;
    /**
     * Default collection of array rules
     */
    static rules: {
        compact: (options?: undefined) => Validation<undefined>;
        notEmpty: (options?: undefined) => Validation<undefined>;
        distinct: (options: {
            fields?: string | string[] | undefined;
        }) => Validation<{
            fields?: string | string[] | undefined;
        }>;
        minLength: (options: {
            min: number;
        }) => Validation<{
            min: number;
        }>;
        maxLength: (options: {
            max: number;
        }) => Validation<{
            max: number;
        }>;
        fixedLength: (options: {
            size: number;
        }) => Validation<{
            size: number;
        }>;
    };
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of array type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(schema: Schema, options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Enforce a minimum length on an array field
     */
    minLength(expectedLength: number): this;
    /**
     * Enforce a maximum length on an array field
     */
    maxLength(expectedLength: number): this;
    /**
     * Enforce a fixed length on an array field
     */
    fixedLength(expectedLength: number): this;
    /**
     * Ensure the array is not empty
     */
    notEmpty(): this;
    /**
     * Ensure array elements are distinct/unique
     */
    distinct(fields?: string | string[]): this;
    /**
     * Removes empty strings, null and undefined values from the array
     */
    compact(): this;
    /**
     * Clones the VineArray schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
    /**
     * Compiles to array data type
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ArrayNode;
}

/**
 * Group conditional represents a sub-set of object wrapped
 * inside a conditional
 */
declare class GroupConditional<Properties extends Record<string, SchemaTypes>, Output, CamelCaseOutput> {
    #private;
    [OTYPE]: Output;
    [COTYPE]: CamelCaseOutput;
    constructor(conditional: ConditionalFn<Record<string, unknown>>, properties: Properties);
    /**
     * Compiles to a union conditional
     */
    [PARSE](refs: RefsStore, options: ParserOptions): ObjectGroupNode['conditions'][number];
}

/**
 * Object group represents a group with multiple conditionals, where each
 * condition returns a set of object properties to merge into the
 * existing object.
 */
declare class ObjectGroup<Conditional extends GroupConditional<any, any, any>> {
    #private;
    [OTYPE]: Conditional[typeof OTYPE];
    [COTYPE]: Conditional[typeof COTYPE];
    constructor(conditionals: Conditional[]);
    /**
     * Clones the ObjectGroup schema type.
     */
    clone(): this;
    /**
     * Define a fallback method to invoke when all of the group conditions
     * fail. You may use this method to report an error.
     */
    otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this;
    /**
     * Compiles the group
     */
    [PARSE](refs: RefsStore, options: ParserOptions): ObjectGroupNode;
}

/**
 * Converts schema properties to camelCase
 */
declare class VineCamelCaseObject<Schema extends VineObject<any, any, any>> extends BaseModifiersType<Schema[typeof COTYPE], Schema[typeof COTYPE]> {
    #private;
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of object type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(schema: Schema);
    /**
     * Clone object
     */
    clone(): this;
    /**
     * Compiles the schema type to a compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode;
}
/**
 * VineObject represents an object value in the validation
 * schema.
 */
declare class VineObject<Properties extends Record<string, SchemaTypes>, Output, CamelCaseOutput> extends BaseType<Output, CamelCaseOutput> {
    #private;
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of object type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(properties: Properties, options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Returns a clone copy of the object properties. The object groups
     * are not copied to keep the implementations simple and easy to
     * reason about.
     */
    getProperties(): Properties;
    /**
     * Copy unknown properties to the final output.
     */
    allowUnknownProperties<Value>(): VineObject<Properties, Output & {
        [K: string]: Value;
    }, CamelCaseOutput & {
        [K: string]: Value;
    }>;
    /**
     * Merge a union to the object groups. The union can be a "vine.union"
     * with objects, or a "vine.object.union" with properties.
     */
    merge<Group extends ObjectGroup<GroupConditional<any, any, any>>>(group: Group): VineObject<Properties, Output & Group[typeof OTYPE], CamelCaseOutput & Group[typeof COTYPE]>;
    /**
     * Clone object
     */
    clone(): this;
    /**
     * Applies camelcase transform
     */
    toCamelCase(): VineCamelCaseObject<this>;
    /**
     * Compiles the schema type to a compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode;
}

/**
 * Register a callback to validate the object keys
 */
declare const validateKeysRule: (options: (keys: string[], field: FieldContext) => void) => Validation<(keys: string[], field: FieldContext) => void>;

/**
 * VineRecord represents an object of key-value pair in which
 * keys are unknown
 */
declare class VineRecord<Schema extends SchemaTypes> extends BaseType<{
    [K: string]: Schema[typeof OTYPE];
}, {
    [K: string]: Schema[typeof COTYPE];
}> {
    #private;
    /**
     * Default collection of record rules
     */
    static rules: {
        maxLength: (options: {
            max: number;
        }) => Validation<{
            max: number;
        }>;
        minLength: (options: {
            min: number;
        }) => Validation<{
            min: number;
        }>;
        fixedLength: (options: {
            size: number;
        }) => Validation<{
            size: number;
        }>;
        validateKeys: (options: (keys: string[], field: _vinejs_compiler_types.FieldContext) => void) => Validation<(keys: string[], field: _vinejs_compiler_types.FieldContext) => void>;
    };
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of object type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(schema: Schema, options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Enforce a minimum length on an object field
     */
    minLength(expectedLength: number): this;
    /**
     * Enforce a maximum length on an object field
     */
    maxLength(expectedLength: number): this;
    /**
     * Enforce a fixed length on an object field
     */
    fixedLength(expectedLength: number): this;
    /**
     * Register a callback to validate the object keys
     */
    validateKeys(...args: Parameters<typeof validateKeysRule>): this;
    /**
     * Clones the VineRecord schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
    /**
     * Compiles to record data type
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): RecordNode;
}

/**
 * Validates the value to be a valid email address
 */
declare const emailRule: (options?: validator_lib_isEmail_js.IsEmailOptions | undefined) => Validation<validator_lib_isEmail_js.IsEmailOptions | undefined>;
/**
 * Validates the value to be a valid mobile number
 */
declare const mobileRule: (options?: MobileOptions | ((field: FieldContext) => MobileOptions | undefined) | undefined) => Validation<MobileOptions | ((field: FieldContext) => MobileOptions | undefined) | undefined>;
/**
 * Validates the value to be a valid URL
 */
declare const urlRule: (options?: validator_lib_isURL_js.IsURLOptions | undefined) => Validation<validator_lib_isURL_js.IsURLOptions | undefined>;
/**
 * Normalize a URL
 */
declare const normalizeUrlRule: (options?: normalize_url.Options | undefined) => Validation<normalize_url.Options | undefined>;
/**
 * Validates the value to be a valid credit card number
 */
declare const creditCardRule: (options?: CreditCardOptions | ((field: FieldContext) => CreditCardOptions | void | undefined) | undefined) => Validation<CreditCardOptions | ((field: FieldContext) => CreditCardOptions | void | undefined) | undefined>;
/**
 * Validates the value to be a valid passport number
 */
declare const passportRule: (options: PassportOptions | ((field: FieldContext) => PassportOptions)) => Validation<PassportOptions | ((field: FieldContext) => PassportOptions)>;
/**
 * Validates the value to be a valid postal code
 */
declare const postalCodeRule: (options?: PostalCodeOptions | ((field: FieldContext) => PostalCodeOptions | void | undefined) | undefined) => Validation<PostalCodeOptions | ((field: FieldContext) => PostalCodeOptions | void | undefined) | undefined>;
/**
 * Validates the value to be a valid UUID
 */
declare const uuidRule: (options?: {
    version?: (1 | 2 | 4 | 3 | 5)[] | undefined;
} | undefined) => Validation<{
    version?: (1 | 2 | 4 | 3 | 5)[] | undefined;
} | undefined>;

/**
 * VineString represents a string value in the validation schema.
 */
declare class VineString extends BaseLiteralType<string, string> {
    static rules: {
        in: (options: {
            choices: string[] | ((field: FieldContext) => string[]);
        }) => Validation<{
            choices: string[] | ((field: FieldContext) => string[]);
        }>;
        jwt: (options?: undefined) => Validation<undefined>;
        url: (options?: validator_lib_isURL_js.IsURLOptions | undefined) => Validation<validator_lib_isURL_js.IsURLOptions | undefined>;
        iban: (options?: undefined) => Validation<undefined>;
        uuid: (options?: {
            version?: (1 | 2 | 4 | 3 | 5)[] | undefined;
        } | undefined) => Validation<{
            version?: (1 | 2 | 4 | 3 | 5)[] | undefined;
        } | undefined>;
        trim: (options?: undefined) => Validation<undefined>;
        email: (options?: validator_lib_isEmail_js.IsEmailOptions | undefined) => Validation<validator_lib_isEmail_js.IsEmailOptions | undefined>;
        alpha: (options?: AlphaOptions | undefined) => Validation<AlphaOptions | undefined>;
        ascii: (options?: undefined) => Validation<undefined>;
        notIn: (options: {
            list: string[] | ((field: FieldContext) => string[]);
        }) => Validation<{
            list: string[] | ((field: FieldContext) => string[]);
        }>;
        regex: (options: RegExp) => Validation<RegExp>;
        escape: (options?: undefined) => Validation<undefined>;
        sameAs: (options: {
            otherField: string;
        }) => Validation<{
            otherField: string;
        }>;
        mobile: (options?: MobileOptions | ((field: FieldContext) => MobileOptions | undefined) | undefined) => Validation<MobileOptions | ((field: FieldContext) => MobileOptions | undefined) | undefined>;
        string: (options?: undefined) => Validation<undefined>;
        hexCode: (options?: undefined) => Validation<undefined>;
        passport: (options: PassportOptions | ((field: FieldContext) => PassportOptions)) => Validation<PassportOptions | ((field: FieldContext) => PassportOptions)>;
        endsWith: (options: {
            substring: string;
        }) => Validation<{
            substring: string;
        }>;
        confirmed: (options?: {
            confirmationField: string;
        } | undefined) => Validation<{
            confirmationField: string;
        } | undefined>;
        activeUrl: (options?: undefined) => Validation<undefined>;
        minLength: (options: {
            min: number;
        }) => Validation<{
            min: number;
        }>;
        notSameAs: (options: {
            otherField: string;
        }) => Validation<{
            otherField: string;
        }>;
        maxLength: (options: {
            max: number;
        }) => Validation<{
            max: number;
        }>;
        ipAddress: (options?: {
            version: 4 | 6;
        } | undefined) => Validation<{
            version: 4 | 6;
        } | undefined>;
        creditCard: (options?: CreditCardOptions | ((field: FieldContext) => void | CreditCardOptions | undefined) | undefined) => Validation<CreditCardOptions | ((field: FieldContext) => void | CreditCardOptions | undefined) | undefined>;
        postalCode: (options?: PostalCodeOptions | ((field: FieldContext) => void | PostalCodeOptions | undefined) | undefined) => Validation<PostalCodeOptions | ((field: FieldContext) => void | PostalCodeOptions | undefined) | undefined>;
        startsWith: (options: {
            substring: string;
        }) => Validation<{
            substring: string;
        }>;
        toUpperCase: (options?: string | string[] | undefined) => Validation<string | string[] | undefined>;
        toLowerCase: (options?: string | string[] | undefined) => Validation<string | string[] | undefined>;
        toCamelCase: (options?: undefined) => Validation<undefined>;
        fixedLength: (options: {
            size: number;
        }) => Validation<{
            size: number;
        }>;
        coordinates: (options?: undefined) => Validation<undefined>;
        normalizeUrl: (options?: normalize_url.Options | undefined) => Validation<normalize_url.Options | undefined>;
        alphaNumeric: (options?: AlphaOptions | undefined) => Validation<AlphaOptions | undefined>;
        normalizeEmail: (options?: validator.default.NormalizeEmailOptions | undefined) => Validation<validator.default.NormalizeEmailOptions | undefined>;
    };
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of string type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Validates the value to be a valid URL
     */
    url(...args: Parameters<typeof urlRule>): this;
    /**
     * Validates the value to be an active URL
     */
    activeUrl(): this;
    /**
     * Validates the value to be a valid email address
     */
    email(...args: Parameters<typeof emailRule>): this;
    /**
     * Validates the value to be a valid mobile number
     */
    mobile(...args: Parameters<typeof mobileRule>): this;
    /**
     * Validates the value to be a valid IP address.
     */
    ipAddress(version?: 4 | 6): this;
    /**
     * Validates the value to be a valid hex color code
     */
    hexCode(): this;
    /**
     * Validates the value to be an active URL
     */
    regex(expression: RegExp): this;
    /**
     * Validates the value to contain only letters
     */
    alpha(options?: AlphaOptions): this;
    /**
     * Validates the value to contain only letters and
     * numbers
     */
    alphaNumeric(options?: AlphaNumericOptions): this;
    /**
     * Enforce a minimum length on a string field
     */
    minLength(expectedLength: number): this;
    /**
     * Enforce a maximum length on a string field
     */
    maxLength(expectedLength: number): this;
    /**
     * Enforce a fixed length on a string field
     */
    fixedLength(expectedLength: number): this;
    /**
     * Ensure the field under validation is confirmed by
     * having another field with the same name.
     */
    confirmed(options?: {
        confirmationField: string;
    }): this;
    /**
     * Trims whitespaces around the string value
     */
    trim(): this;
    /**
     * Normalizes the email address
     */
    normalizeEmail(options?: NormalizeEmailOptions): this;
    /**
     * Converts the field value to UPPERCASE.
     */
    toUpperCase(): this;
    /**
     * Converts the field value to lowercase.
     */
    toLowerCase(): this;
    /**
     * Converts the field value to camelCase.
     */
    toCamelCase(): this;
    /**
     * Escape string for HTML entities
     */
    escape(): this;
    /**
     * Normalize a URL
     */
    normalizeUrl(...args: Parameters<typeof normalizeUrlRule>): this;
    /**
     * Ensure the value starts with the pre-defined substring
     */
    startsWith(substring: string): this;
    /**
     * Ensure the value ends with the pre-defined substring
     */
    endsWith(substring: string): this;
    /**
     * Ensure the value ends with the pre-defined substring
     */
    sameAs(otherField: string): this;
    /**
     * Ensure the value ends with the pre-defined substring
     */
    notSameAs(otherField: string): this;
    /**
     * Ensure the field's value under validation is a subset of the pre-defined list.
     */
    in(choices: string[] | ((field: FieldContext) => string[])): this;
    /**
     * Ensure the field's value under validation is not inside the pre-defined list.
     */
    notIn(list: string[] | ((field: FieldContext) => string[])): this;
    /**
     * Validates the value to be a valid credit card number
     */
    creditCard(...args: Parameters<typeof creditCardRule>): this;
    /**
     * Validates the value to be a valid passport number
     */
    passport(...args: Parameters<typeof passportRule>): this;
    /**
     * Validates the value to be a valid postal code
     */
    postalCode(...args: Parameters<typeof postalCodeRule>): this;
    /**
     * Validates the value to be a valid UUID
     */
    uuid(...args: Parameters<typeof uuidRule>): this;
    /**
     * Validates the value contains ASCII characters only
     */
    ascii(): this;
    /**
     * Validates the value to be a valid IBAN number
     */
    iban(): this;
    /**
     * Validates the value to be a valid JWT token
     */
    jwt(): this;
    /**
     * Ensure the value is a string with latitude and longitude coordinates
     */
    coordinates(): this;
    /**
     * Clones the VineString schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * VineNumber represents a numeric value in the validation schema.
 */
declare class VineNumber extends BaseLiteralType<number, number> {
    protected options: FieldOptions & {
        strict?: boolean;
    };
    /**
     * Default collection of number rules
     */
    static rules: {
        max: (options: {
            max: number;
        }) => Validation<{
            max: number;
        }>;
        min: (options: {
            min: number;
        }) => Validation<{
            min: number;
        }>;
        range: (options: {
            min: number;
            max: number;
        }) => Validation<{
            min: number;
            max: number;
        }>;
        number: (options: {
            strict?: boolean | undefined;
        }) => Validation<{
            strict?: boolean | undefined;
        }>;
        decimal: (options: {
            range: [number, (number | undefined)?];
        }) => Validation<{
            range: [number, (number | undefined)?];
        }>;
        negative: (options?: undefined) => Validation<undefined>;
        positive: (options?: undefined) => Validation<undefined>;
        withoutDecimals: (options?: undefined) => Validation<undefined>;
    };
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of number type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(options?: Partial<FieldOptions> & {
        strict?: boolean;
    }, validations?: Validation<any>[]);
    /**
     * Enforce a minimum value for the number input
     */
    min(value: number): this;
    /**
     * Enforce a maximum value for the number input
     */
    max(value: number): this;
    /**
     * Enforce value to be within the range of minimum and maximum output.
     */
    range(value: [min: number, max: number]): this;
    /**
     * Enforce the value be a positive number
     */
    positive(): this;
    /**
     * Enforce the value be a negative number
     */
    negative(): this;
    /**
     * Enforce the value to have fixed or range
     * of decimal places
     */
    decimal(range: number | [number, number]): this;
    /**
     * Enforce the value to be an integer (aka without decimals)
     */
    withoutDecimals(): this;
    /**
     * Clones the VineNumber schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * VineBoolean represents a boolean value in the validation schema.
 */
declare class VineBoolean extends BaseLiteralType<boolean, boolean> {
    /**
     * Default collection of boolean rules
     */
    static rules: {
        boolean: (options: {
            strict?: boolean | undefined;
        }) => Validation<{
            strict?: boolean | undefined;
        }>;
    };
    protected options: FieldOptions & {
        strict?: boolean;
    };
    /**
     * The property must be implemented for "unionOfTypes"
     */
    [UNIQUE_NAME]: string;
    /**
     * Checks if the value is of boolean type. The method must be
     * implemented for "unionOfTypes"
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(options?: Partial<FieldOptions> & {
        strict?: boolean;
    }, validations?: Validation<any>[]);
    /**
     * Clones the VineBoolean schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * VineLiteral represents a type that matches an exact value
 */
declare class VineLiteral<Value> extends BaseLiteralType<Value, Value> {
    #private;
    /**
     * Default collection of literal rules
     */
    static rules: {
        equals: (options: {
            expectedValue: any;
        }) => Validation<{
            expectedValue: any;
        }>;
    };
    constructor(value: Value, options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Clones the VineLiteral schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * Copy-pasted from
 * https://github.com/ts-essentials/ts-essentials/blob/3f5d46a203cad06728fbf2a089a5b39bd473bf4e/lib/camel-case/index.ts
 *
 * Since, we need just one helper, I decided to not pull in the entire package and just copy-paste
 * the types
 */
type IsStringLiteral<Type> = Type extends string ? (string extends Type ? false : true) : false;
type WordInPascalCase<Type> = Capitalize<WordInCamelCase<Uncapitalize<Type & string>>>;
type WordInCamelCase<Type, Character extends string = ''> = Type extends `${Character}${infer NextCharacter}${infer _}` ? NextCharacter extends Capitalize<NextCharacter> ? Character : WordInCamelCase<Type, `${Character}${NextCharacter}`> : Character;
type Separator = '_' | '-';
type IncludesSeparator<Type> = Type extends `${string}${Separator}${string}` ? true : false;
type IsOneWord<Type> = Type extends Lowercase<Type & string> ? true : Type extends Uppercase<Type & string> ? true : false;
type IsCamelCase<Type> = Type extends Uncapitalize<Type & string> ? true : false;
type IsPascalCase<Type> = Type extends Capitalize<Type & string> ? true : false;
/** snake_case, CONSTANT_CASE, kebab-case or COBOL-CASE */
type SeparatorCaseParser<Type, Tuple extends readonly any[] = []> = Type extends `${infer Word}${Separator}${infer Tail}` ? SeparatorCaseParser<Tail, [...Tuple, Lowercase<Word>]> : Type extends `${infer Word}` ? [...Tuple, Lowercase<Word>] : Tuple;
type CamelCaseParser<Type, Tuple extends readonly any[] = []> = Type extends '' ? Tuple : Type extends `${WordInCamelCase<Type & string>}${infer Tail}` ? Type extends `${infer Word}${Tail}` ? CamelCaseParser<Uncapitalize<Tail>, [...Tuple, Lowercase<Word>]> : never : never;
type PascalCaseParser<Type, Tuple extends readonly any[] = []> = Type extends '' ? Tuple : Type extends `${WordInPascalCase<Type & string>}${infer Tail}` ? Type extends `${infer Word}${Tail}` ? PascalCaseParser<Tail, [...Tuple, Lowercase<Word>]> : never : never;
type SplitAnyCase<Type> = IncludesSeparator<Type> extends true ? SeparatorCaseParser<Type> : IsOneWord<Type> extends true ? [Lowercase<Type & string>] : IsCamelCase<Type> extends true ? CamelCaseParser<Type> : IsPascalCase<Type> extends true ? PascalCaseParser<Type> : [];
type PascalCapitalizer<Type, Tuple extends readonly any[] = []> = Type extends [
    infer Head,
    ...infer Tail
] ? Head extends string ? PascalCapitalizer<Tail, [...Tuple, Capitalize<Head>]> : PascalCapitalizer<Tail, Tuple> : Tuple;
type CamelCapitalizer<Type> = Type extends [infer First, ...infer Tail] ? PascalCapitalizer<Tail, [First]> : [];
type Join<Type, JoinedString extends string = ''> = Type extends [infer Head, ...infer Tail] ? Head extends string ? Join<Tail, `${JoinedString}${Head}`> : Join<Tail> : JoinedString;
type CamelCase<Type> = IsStringLiteral<Type> extends true ? Join<CamelCapitalizer<SplitAnyCase<Type>>> : Type;

/**
 * VineAccepted represents a checkbox input that must be checked
 */
declare class VineAccepted extends BaseLiteralType<true, true> {
    /**
     * Default collection of accepted rules
     */
    static rules: {
        accepted: (options?: undefined) => Validation<undefined>;
    };
    constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]);
    /**
     * Clones the VineAccepted schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * Create an object group. Groups are used to conditionally merge properties
 * to an existing object.
 */
declare function group<Conditional extends GroupConditional<any, any, any>>(conditionals: Conditional[]): ObjectGroup<Conditional>;
declare namespace group {
    var _a: <Properties extends Record<string, SchemaTypes>>(conditon: (value: Record<string, unknown>, field: FieldContext) => any, properties: Properties) => GroupConditional<Properties, { [K in keyof Properties]: Properties[K][typeof OTYPE]; }, { [K_1 in keyof Properties as CamelCase<K_1 & string>]: Properties[K_1][typeof COTYPE]; }>;
    var _b: <Properties extends Record<string, SchemaTypes>>(properties: Properties) => GroupConditional<Properties, { [K in keyof Properties]: Properties[K][typeof OTYPE]; }, { [K_1 in keyof Properties as CamelCase<K_1 & string>]: Properties[K_1][typeof COTYPE]; }>;
    export { _a as if, _b as else };
}

/**
 * VineNativeEnum represents a enum data type that performs validation
 * against a pre-defined choices list.
 *
 * The choices list is derived from TypeScript enum data type or an
 * object
 */
declare class VineNativeEnum<Values extends EnumLike> extends BaseLiteralType<Values[keyof Values], Values[keyof Values]> {
    #private;
    /**
     * Default collection of enum rules
     */
    static rules: {
        enum: (options: {
            choices: readonly any[] | ((field: _vinejs_compiler_types.FieldContext) => readonly any[]);
        }) => Validation<{
            choices: readonly any[] | ((field: _vinejs_compiler_types.FieldContext) => readonly any[]);
        }>;
    };
    constructor(values: Values, options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Clones the VineNativeEnum schema type. The applied options
     * and validations are copied to the new instance
     */
    clone(): this;
}

/**
 * Vine union represents a union data type. A union is a collection
 * of conditionals and each condition has an associated schema
 */
declare class VineUnionOfTypes<Schema extends SchemaTypes> implements ConstructableSchema<Schema[typeof OTYPE], Schema[typeof COTYPE]> {
    #private;
    [OTYPE]: Schema[typeof OTYPE];
    [COTYPE]: Schema[typeof COTYPE];
    constructor(schemas: Schema[]);
    /**
     * Define a fallback method to invoke when all of the union conditions
     * fail. You may use this method to report an error.
     */
    otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this;
    /**
     * Clones the VineUnionOfTypes schema type.
     */
    clone(): this;
    /**
     * Compiles to a union
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode;
}

/**
 * Schema builder exposes methods to construct a Vine schema. You may
 * add custom methods to it using macros.
 */
declare class SchemaBuilder extends Macroable {
    /**
     * Define a sub-object as a union
     */
    group: typeof group;
    /**
     * Define a union value
     */
    union: typeof union;
    /**
     * Define a string value
     */
    string(): VineString;
    /**
     * Define a boolean value
     */
    boolean(options?: {
        strict: boolean;
    }): VineBoolean;
    /**
     * Validate a checkbox to be checked
     */
    accepted(): VineAccepted;
    /**
     * Define a number value
     */
    number(options?: {
        strict: boolean;
    }): VineNumber;
    /**
     * Define a schema type in which the input value
     * matches the pre-defined value
     */
    literal<const Value>(value: Value): VineLiteral<Value>;
    /**
     * Define an object with known properties. You may call "allowUnknownProperties"
     * to merge unknown properties.
     */
    object<Properties extends Record<string, SchemaTypes>>(properties: Properties): VineObject<Properties, { [K in keyof Properties]: Properties[K][typeof OTYPE]; }, { [K_1 in keyof Properties as CamelCase<K_1 & string>]: Properties[K_1][typeof COTYPE]; }>;
    /**
     * Define an array field and validate its children elements.
     */
    array<Schema extends SchemaTypes>(schema: Schema): VineArray<Schema>;
    /**
     * Define an array field with known length and each children
     * element may have its own schema.
     */
    tuple<Schema extends SchemaTypes[]>(schemas: [...Schema]): VineTuple<Schema, { [K in keyof Schema]: Schema[K][typeof OTYPE]; }, { [K_1 in keyof Schema]: Schema[K_1][typeof COTYPE]; }>;
    /**
     * Define an object field with key-value pair. The keys in
     * a record are unknown and values can be of a specific
     * schema type.
     */
    record<Schema extends SchemaTypes>(schema: Schema): VineRecord<Schema>;
    /**
     * Define a field whose value matches the enum choices.
     */
    enum<const Values extends readonly unknown[]>(values: Values | ((field: FieldContext) => Values)): VineEnum<Values>;
    enum<Values extends EnumLike>(values: Values): VineNativeEnum<Values>;
    /**
     * Allow the field value to be anything
     */
    any(): VineAny;
    /**
     * Define a union of unique schema types.
     */
    unionOfTypes<Schema extends SchemaTypes>(schemas: Schema[]): VineUnionOfTypes<Schema>;
}

/**
 * Vine Validator exposes the API to validate data using a pre-compiled
 * schema.
 */
declare class VineValidator<Schema extends SchemaTypes, MetaData extends undefined | Record<string, any>> {
    #private;
    /**
     * Reference to static types
     */
    [OTYPE]: Schema[typeof OTYPE];
    /**
     * Messages provider to use on the validator
     */
    messagesProvider: MessagesProviderContact;
    /**
     * Error reporter to use on the validator
     */
    errorReporter: () => ErrorReporterContract;
    constructor(schema: Schema, options: {
        convertEmptyStringsToNull: boolean;
        metaDataValidator?: MetaDataValidator;
        messagesProvider: MessagesProviderContact;
        errorReporter: () => ErrorReporterContract;
    });
    /**
     * Validate data against a schema. Optionally, you can share metaData with
     * the validator
     *
     * ```ts
     * await validator.validate(data)
     * await validator.validate(data, { meta: {} })
     *
     * await validator.validate(data, {
     *   meta: { userId: auth.user.id },
     *   errorReporter,
     *   messagesProvider
     * })
     * ```
     */
    validate(data: any, ...[options]: [undefined] extends MetaData ? [options?: ValidationOptions<MetaData> | undefined] : [options: ValidationOptions<MetaData>]): Promise<Infer<Schema>>;
}

/**
 * Validate user input with type-safety using a pre-compiled schema.
 */
declare class Vine extends SchemaBuilder {
    /**
     * Messages provider to use on the validator
     */
    messagesProvider: MessagesProviderContact;
    /**
     * Error reporter to use on the validator
     */
    errorReporter: () => ErrorReporterContract;
    /**
     * Control whether or not to convert empty strings to null
     */
    convertEmptyStringsToNull: boolean;
    /**
     * Helpers to perform type-checking or cast types keeping
     * HTML forms serialization behavior in mind.
     */
    helpers: {
        exists(value: any): boolean;
        isMissing(value: any): boolean;
        isTrue(value: any): boolean;
        isFalse(value: any): boolean;
        isString(value: unknown): value is string;
        isObject<Value>(value: unknown): value is Record<PropertyKey, Value>;
        hasKeys(value: Record<string, any>, keys: string[]): boolean;
        isArray<Value_1>(value: unknown): value is Value_1[];
        isNumeric(value: any): boolean;
        asNumber(value: any): number;
        asBoolean(value: any): boolean | null;
        isEmail: typeof validator_lib_isEmail_js.default;
        isURL: typeof validator_lib_isURL_js.default;
        isAlpha: typeof validator.default.isAlpha;
        isAlphaNumeric: typeof validator.default.isAlphanumeric;
        isIP: typeof validator.default.isIP;
        isUUID: typeof validator.default.isUUID;
        isAscii: typeof validator.default.isAscii;
        isCreditCard: typeof validator.default.isCreditCard;
        isIBAN: typeof isIBAN.default;
        isJWT: typeof validator.default.isJWT;
        isLatLong: typeof validator.default.isLatLong;
        isMobilePhone: typeof validator.default.isMobilePhone;
        isPassportNumber: typeof validator.default.isPassportNumber;
        isPostalCode: typeof validator.default.isPostalCode;
        isSlug: typeof validator.default.isSlug;
        isDecimal: typeof validator.default.isDecimal;
        mobileLocales: validator.default.MobilePhoneLocale[];
        postalCountryCodes: validator.default.PostalCodeLocale[];
        passportCountryCodes: readonly ["AM", "AR", "AT", "AU", "AZ", "BE", "BG", "BR", "BY", "CA", "CH", "CY", "CZ", "DE", "DK", "DZ", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IN", "ID", "IR", "IS", "IT", "JM", "JP", "KR", "KZ", "LI", "LT", "LU", "LV", "LY", "MT", "MZ", "MY", "MX", "NL", "NZ", "PH", "PK", "PL", "PT", "RO", "RU", "SE", "SL", "SK", "TH", "TR", "UA", "US"];
        isHexColor: (value: string) => boolean;
        isActiveURL: (url: string) => Promise<boolean>;
        isDistinct: (dataSet: any[], fields?: string | string[] | undefined) => boolean;
    };
    /**
     * Convert a validation function to a Vine schema rule
     */
    createRule: typeof createRule;
    /**
     * Pre-compiles a schema into a validation function.
     *
     * ```ts
     * const validate = vine.compile(schema)
     * await validate({ data })
     * ```
     */
    compile<Schema extends SchemaTypes>(schema: Schema): VineValidator<Schema, Record<string, any> | undefined>;
    /**
     * Define a callback to validate the metadata given to the validator
     * at runtime
     */
    withMetaData<MetaData extends Record<string, any>>(callback?: MetaDataValidator): {
        compile: <Schema extends SchemaTypes>(schema: Schema) => VineValidator<Schema, MetaData>;
    };
    /**
     * Validate data against a schema. Optionally, you can define
     * error messages, fields, a custom messages provider,
     * or an error reporter.
     *
     * ```ts
     * await vine.validate({ schema, data })
     * await vine.validate({ schema, data, messages, fields })
     *
     * await vine.validate({ schema, data, messages, fields }, {
     *   errorReporter
     * })
     * ```
     */
    validate<Schema extends SchemaTypes>(options: {
        /**
         * Schema to use for validation
         */
        schema: Schema;
        /**
         * Data to validate
         */
        data: any;
    } & ValidationOptions<Record<string, any> | undefined>): Promise<Infer<Schema>>;
}

/**
 * Create an instance of validation error
 */
declare const E_VALIDATION_ERROR: typeof ValidationError;

declare const main_E_VALIDATION_ERROR: typeof E_VALIDATION_ERROR;
declare namespace main {
  export {
    main_E_VALIDATION_ERROR as E_VALIDATION_ERROR,
  };
}

/**
 * Default messages provider performs messages lookup inside
 * a collection of key-value pair.
 */
declare class SimpleMessagesProvider implements MessagesProviderContact {
    #private;
    constructor(messages: ValidationMessages, fields: ValidationFields);
    /**
     * Returns a validation message for a given field + rule.
     */
    getMessage(rawMessage: string, rule: string, field: FieldContext, args?: Record<string, any>): string;
}

declare const vine: Vine;

export { BaseLiteralType, BaseModifiersType, BaseType, SimpleMessagesProvider, Vine, VineAccepted, VineAny, VineArray, VineBoolean, VineEnum, VineLiteral, VineNumber, VineObject, VineRecord, VineString, VineTuple, VineUnion, VineValidator, vine as default, main as errors };
