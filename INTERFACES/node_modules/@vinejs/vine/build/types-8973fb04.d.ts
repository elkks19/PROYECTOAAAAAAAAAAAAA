import { RefsStore, CompilerNodes, FieldContext, TransformFn, ParseFn, ErrorReporterContract as ErrorReporterContract$1, MessagesProviderContact } from '@vinejs/compiler/types';
import { Options } from 'normalize-url';
import validator_lib_isURL_js__default, { IsURLOptions } from 'validator/lib/isURL.js';
import validator_lib_isEmail_js__default, { IsEmailOptions } from 'validator/lib/isEmail.js';
import 'validator/lib/normalizeEmail.js';
import { MobilePhoneLocale, IsMobilePhoneOptions } from 'validator/lib/isMobilePhone.js';
import { PostalCodeLocale } from 'validator/lib/isPostalCode.js';
import * as validator from 'validator';
import isIBAN__default from 'validator/lib/isIBAN.js';

/**
 * Collection of helpers used across the codebase to coerce
 * and type-check values from HTML forms.
 */
declare const helpers: {
    /**
     * Returns true when value is not null and neither
     * undefined
     */
    exists(value: any): boolean;
    /**
     * Returns true when value is null or value is undefined
     */
    isMissing(value: any): boolean;
    /**
     * Returns true when the value is one of the following.
     *
     * true
     * 1
     * "1"
     * "true"
     * "on"
     */
    isTrue(value: any): boolean;
    /**
     * Returns true when the value is one of the following.
     *
     * false
     * 0
     * "0"
     * "false"
     */
    isFalse(value: any): boolean;
    /**
     * Check if the value is a valid string. This method narrows
     * the type of value to string.
     */
    isString(value: unknown): value is string;
    /**
     * Check if the value is a plain JavaScript object. This method
     * filters out null and Arrays and does not consider them as Objects.
     */
    isObject<Value>(value: unknown): value is Record<PropertyKey, Value>;
    /**
     * Check if an object has all the mentioned keys
     */
    hasKeys(value: Record<string, any>, keys: string[]): boolean;
    /**
     * Check if the value is an Array.
     */
    isArray<Value_1>(value: unknown): value is Value_1[];
    /**
     * Check if the value is a number or a string representation of a number.
     */
    isNumeric(value: any): boolean;
    /**
     * Casts the value to a number using the Number method.
     * Returns NaN when unable to cast.
     */
    asNumber(value: any): number;
    /**
     * Casts the value to a boolean.
     *
     * - [true, 1, "1", "true", "on"] will be converted to true.
     * - [false, 0, "0", "false"] will be converted to false.
     * - Everything else will return null. So make sure to handle that case.
     */
    asBoolean(value: any): boolean | null;
    isEmail: typeof validator_lib_isEmail_js__default.default;
    isURL: typeof validator_lib_isURL_js__default.default;
    isAlpha: typeof validator.default.isAlpha;
    isAlphaNumeric: typeof validator.default.isAlphanumeric;
    isIP: typeof validator.default.isIP;
    isUUID: typeof validator.default.isUUID;
    isAscii: typeof validator.default.isAscii;
    isCreditCard: typeof validator.default.isCreditCard;
    isIBAN: typeof isIBAN__default.default;
    isJWT: typeof validator.default.isJWT;
    isLatLong: typeof validator.default.isLatLong;
    isMobilePhone: typeof validator.default.isMobilePhone;
    isPassportNumber: typeof validator.default.isPassportNumber;
    isPostalCode: typeof validator.default.isPostalCode;
    isSlug: typeof validator.default.isSlug;
    isDecimal: typeof validator.default.isDecimal;
    mobileLocales: validator.default.MobilePhoneLocale[];
    postalCountryCodes: validator.default.PostalCodeLocale[];
    passportCountryCodes: readonly ["AM", "AR", "AT", "AU", "AZ", "BE", "BG", "BR", "BY", "CA", "CH", "CY", "CZ", "DE", "DK", "DZ", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IN", "ID", "IR", "IS", "IT", "JM", "JP", "KR", "KZ", "LI", "LT", "LU", "LV", "LY", "MT", "MZ", "MY", "MX", "NL", "NZ", "PH", "PK", "PL", "PT", "RO", "RU", "SE", "SL", "SK", "TH", "TR", "UA", "US"];
    /**
     * Check if the value is a valid color hexcode
     */
    isHexColor: (value: string) => boolean;
    /**
     * Check if a URL has valid `A` or `AAAA` DNS records
     */
    isActiveURL: (url: string) => Promise<boolean>;
    /**
     * Check if all the elements inside the dataset are unique.
     *
     * In case of an array of objects, you must provide one or more keys
     * for the fields that must be unique across the objects.
     *
     * ```ts
     * helpers.isDistinct([1, 2, 4, 5]) // true
     *
     * // Null and undefined values are ignored
     * helpers.isDistinct([1, null, 2, null, 4, 5]) // true
     *
     * helpers.isDistinct([
     *   {
     *     email: 'foo@bar.com',
     *     name: 'foo'
     *   },
     *   {
     *     email: 'baz@bar.com',
     *     name: 'baz'
     *   }
     * ], 'email') // true
     *
     * helpers.isDistinct([
     *   {
     *     email: 'foo@bar.com',
     *     tenant_id: 1,
     *     name: 'foo'
     *   },
     *   {
     *     email: 'foo@bar.com',
     *     tenant_id: 2,
     *     name: 'baz'
     *   }
     * ], ['email', 'tenant_id']) // true
     * ```
     */
    isDistinct: (dataSet: any[], fields?: string | string[]) => boolean;
};

/**
 * Validation error is a superset of Error class with validation
 * error messages
 */
declare class ValidationError extends Error {
    messages: any;
    /**
     * Http status code for the validation error
     */
    status: number;
    /**
     * Internal code for handling the validation error
     * exception
     */
    code: string;
    constructor(messages: any, options?: ErrorOptions);
    get [Symbol.toStringTag](): string;
    toString(): string;
}

/**
 * The symbol to define a unique name for the schema type
 */
declare const UNIQUE_NAME: unique symbol;
/**
 * The symbol to check if a value is of the given schema
 * type
 */
declare const IS_OF_TYPE: unique symbol;
/**
 * The symbol for the compile method
 */
declare const PARSE: unique symbol;
/**
 * The symbol for the opaque type
 */
declare const OTYPE: unique symbol;
/**
 * The symbol for the camelcase opaque type
 */
declare const COTYPE: unique symbol;
/**
 * The symbol to generate a validation rule from rule builder
 */
declare const VALIDATION: unique symbol;

declare const symbols_COTYPE: typeof COTYPE;
declare const symbols_IS_OF_TYPE: typeof IS_OF_TYPE;
declare const symbols_OTYPE: typeof OTYPE;
declare const symbols_PARSE: typeof PARSE;
declare const symbols_UNIQUE_NAME: typeof UNIQUE_NAME;
declare const symbols_VALIDATION: typeof VALIDATION;
declare namespace symbols {
  export {
    symbols_COTYPE as COTYPE,
    symbols_IS_OF_TYPE as IS_OF_TYPE,
    symbols_OTYPE as OTYPE,
    symbols_PARSE as PARSE,
    symbols_UNIQUE_NAME as UNIQUE_NAME,
    symbols_VALIDATION as VALIDATION,
  };
}

/**
 * Options accepted by the mobile number validation
 */
type MobileOptions = {
    locale?: MobilePhoneLocale[];
} & IsMobilePhoneOptions;
/**
 * Options accepted by the email address validation
 */
type EmailOptions = IsEmailOptions;

/**
 * Options accepted by the URL validation
 */
type URLOptions = IsURLOptions;
/**
 * Options accepted by the credit card validation
 */
type CreditCardOptions = {
    provider: ('amex' | 'dinersclub' | 'discover' | 'jcb' | 'mastercard' | 'unionpay' | 'visa')[];
};
/**
 * Options accepted by the passport validation
 */
type PassportOptions = {
    countryCode: (typeof helpers)['passportCountryCodes'][number][];
};
/**
 * Options accepted by the postal code validation
 */
type PostalCodeOptions = {
    countryCode: PostalCodeLocale[];
};
/**
 * Options accepted by the alpha rule
 */
type AlphaOptions = {
    allowSpaces?: boolean;
    allowUnderscores?: boolean;
    allowDashes?: boolean;
};
type NormalizeUrlOptions = Options;
/**
 * Options accepted by the alpha numeric rule
 */
type AlphaNumericOptions = AlphaOptions;

/**
 * Representation of a native enum like type
 */
type EnumLike = {
    [K: string]: string | number;
    [number: number]: string;
};
/**
 * Representation of fields and messages accepted by the messages
 * provider
 */
type ValidationMessages = Record<string, string>;
type ValidationFields = Record<string, string>;
/**
 * Constructable schema type refers to any type that can be
 * constructed for type inference and compiler output
 */
interface ConstructableSchema<Output, CamelCaseOutput> {
    [OTYPE]: Output;
    [COTYPE]: CamelCaseOutput;
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes;
    clone(): this;
    /**
     * Implement if you want schema type to be used with the unionOfTypes
     */
    [UNIQUE_NAME]?: string;
    [IS_OF_TYPE]?: (value: unknown, field: FieldContext) => boolean;
}
type SchemaTypes = ConstructableSchema<any, any>;
/**
 * Representation of a function that performs validation.
 * The function receives the following arguments.
 *
 * - the current value of the input field
 * - runtime options
 * - field context
 */
type Validator<Options extends any> = (value: unknown, options: Options, field: FieldContext) => any | Promise<any>;
/**
 * A validation rule is a combination of a validator and
 * some metadata required at the time of compiling the
 * rule.
 *
 * Think of this type as "Validator" + "metaData"
 */
type ValidationRule<Options extends any> = {
    validator: Validator<Options>;
    isAsync: boolean;
    implicit: boolean;
};
/**
 * Validation is a combination of a validation rule and the options
 * to supply to validator at the time of validating the field.
 *
 * Think of this type as "ValidationRule" + "options"
 */
type Validation<Options extends any> = {
    /**
     * Options to pass to the validator function.
     */
    options?: Options;
    /**
     * The rule to use
     */
    rule: ValidationRule<Options>;
};
/**
 * A rule builder is an object that implements the "VALIDATION"
 * method and returns [[Validation]] type
 */
interface RuleBuilder {
    [VALIDATION](): Validation<any>;
}
/**
 * The transform function to mutate the output value
 */
type Transformer<Schema extends SchemaTypes, Output> = TransformFn<Exclude<Schema[typeof OTYPE], undefined>, Output>;
/**
 * The parser function to mutate the input value
 */
type Parser = ParseFn;
/**
 * A set of options accepted by the field
 */
type FieldOptions = {
    allowNull: boolean;
    bail: boolean;
    isOptional: boolean;
    parse?: Parser;
};
/**
 * Options accepted when compiling schema types.
 */
type ParserOptions = {
    toCamelCase: boolean;
};
/**
 * Method to invoke when union has no match
 */
type UnionNoMatchCallback<Input> = (value: Input, field: FieldContext) => any;
/**
 * Error reporters must implement the reporter contract interface
 */
interface ErrorReporterContract extends ErrorReporterContract$1 {
    createError(): ValidationError;
}
/**
 * The validator function to validate metadata given to a validation
 * pipeline
 */
type MetaDataValidator = (meta: Record<string, any>) => void;
/**
 * Options accepted during the validate call.
 */
type ValidationOptions<MetaData extends Record<string, any> | undefined> = {
    /**
     * Messages provider is used to resolve error messages during
     * the validation lifecycle
     */
    messagesProvider?: MessagesProviderContact;
    /**
     * Validation errors are reported directly to an error reporter. The reporter
     * can decide how to format and output errors.
     */
    errorReporter?: () => ErrorReporterContract;
} & ([undefined] extends MetaData ? {
    meta?: MetaData;
} : {
    meta: MetaData;
});
/**
 * Infers the schema type
 */
type Infer<Schema extends {
    [OTYPE]: any;
}> = Schema[typeof OTYPE];

export { AlphaOptions as A, ConstructableSchema as C, EnumLike as E, FieldOptions as F, IS_OF_TYPE as I, MobileOptions as M, NormalizeUrlOptions as N, OTYPE as O, Parser as P, RuleBuilder as R, SchemaTypes as S, Transformer as T, UnionNoMatchCallback as U, Validator as V, Validation as a, PARSE as b, ParserOptions as c, COTYPE as d, UNIQUE_NAME as e, CreditCardOptions as f, PassportOptions as g, PostalCodeOptions as h, AlphaNumericOptions as i, ErrorReporterContract as j, MetaDataValidator as k, ValidationOptions as l, Infer as m, ValidationError as n, ValidationMessages as o, ValidationFields as p, EmailOptions as q, URLOptions as r, symbols as s, ValidationRule as t };
